# Vault PKI Initialization Job
# Configures Root CA, Intermediate CA, and ACME endpoint
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-init
  namespace: vault-aio
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init
  namespace: vault-aio
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "update", "patch", "get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init
  namespace: vault-aio
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init
subjects:
  - kind: ServiceAccount
    name: vault-init
    namespace: vault-aio
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init-certmanager
  namespace: cert-manager
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "update", "patch", "get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init-certmanager
  namespace: cert-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init-certmanager
subjects:
  - kind: ServiceAccount
    name: vault-init
    namespace: vault-aio
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init-argocd
  namespace: argocd
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "update", "patch", "get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init-argocd
  namespace: argocd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init-argocd
subjects:
  - kind: ServiceAccount
    name: vault-init
    namespace: vault-aio
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-init-scripts
  namespace: vault-aio
data:
  init-vault.sh: |
    #!/bin/sh
    set -e

    VAULT_ADDR="${VAULT_ADDR:-http://vault:8200}"
    VAULT_TOKEN="${VAULT_TOKEN:-root}"

    export VAULT_ADDR VAULT_TOKEN

    echo "=== Vault PKI Initialization Script ==="
    echo "Vault Address: $VAULT_ADDR"

    # Wait for Vault to be ready
    echo "Waiting for Vault to be ready..."
    until vault status 2>/dev/null | grep -q "Sealed.*false"; do
      echo "Vault not ready, waiting..."
      sleep 2
    done
    echo "Vault is ready!"

    # Check if Root CA exists
    ROOT_CA_EXISTS=false
    INT_CA_EXISTS=false

    if vault secrets list 2>/dev/null | grep -q "pki/"; then
      echo "PKI secrets engine already exists, checking configuration..."
      if vault read pki/cert/ca >/dev/null 2>&1; then
        echo "Root CA exists"
        ROOT_CA_EXISTS=true
      fi
    fi

    if vault secrets list 2>/dev/null | grep -q "pki_int/"; then
      if vault read pki_int/cert/ca >/dev/null 2>&1; then
        echo "Intermediate CA exists"
        INT_CA_EXISTS=true
      fi
    fi

    # Configure Root CA if needed
    if [ "$ROOT_CA_EXISTS" != "true" ]; then
      echo ""
      echo "=== Configuring Root CA ==="

      # Enable PKI secrets engine for Root CA
      vault secrets enable -path=pki pki 2>/dev/null || echo "PKI already enabled"

      # Set max TTL to 10 years
      vault secrets tune -max-lease-ttl=87600h pki

      # Generate Root CA
      echo "Generating Root CA certificate..."
      vault write pki/root/generate/internal \
        common_name="Vault AIO Root CA" \
        issuer_name="root-2024" \
        ttl=87600h \
        key_bits=4096

      # Configure CA and CRL URLs
      vault write pki/config/urls \
        issuing_certificates="${VAULT_ADDR}/v1/pki/ca" \
        crl_distribution_points="${VAULT_ADDR}/v1/pki/crl"
    fi

    # Configure Intermediate CA if needed
    if [ "$INT_CA_EXISTS" != "true" ]; then
      echo ""
      echo "=== Configuring Intermediate CA ==="

      # Enable PKI secrets engine for Intermediate CA
      vault secrets enable -path=pki_int pki 2>/dev/null || echo "PKI Int already enabled"

      # Set max TTL to 5 years
      vault secrets tune -max-lease-ttl=43800h pki_int

      # Generate Intermediate CSR
      echo "Generating Intermediate CA CSR..."
      vault write -field=csr pki_int/intermediate/generate/internal \
        common_name="Vault AIO Intermediate CA" \
        issuer_name="intermediate-2024" \
        key_bits=4096 > /tmp/intermediate.csr

      # Sign Intermediate with Root CA
      echo "Signing Intermediate CA with Root CA..."
      vault write -field=certificate pki/root/sign-intermediate \
        csr=@/tmp/intermediate.csr \
        format=pem_bundle \
        ttl=43800h > /tmp/intermediate-signed.crt

      # Set the signed certificate
      echo "Setting signed intermediate certificate..."
      vault write pki_int/intermediate/set-signed certificate=@/tmp/intermediate-signed.crt

      # Configure Intermediate CA URLs
      vault write pki_int/config/urls \
        issuing_certificates="${VAULT_ADDR}/v1/pki_int/ca" \
        crl_distribution_points="${VAULT_ADDR}/v1/pki_int/crl"

      echo ""
      echo "=== Creating PKI Roles ==="

      # Create role for vault-aio.local domain certificates
      vault write pki_int/roles/vault-aio-local \
        allowed_domains="vault-aio.local" \
        allow_subdomains=true \
        allow_bare_domains=true \
        max_ttl=720h \
        key_bits=2048 \
        require_cn=false \
        allow_any_name=false

      # Create role for cert-manager
      vault write pki_int/roles/cert-manager \
        allowed_domains="vault-aio.local,svc.cluster.local" \
        allow_subdomains=true \
        allow_bare_domains=true \
        max_ttl=720h \
        key_bits=2048 \
        require_cn=false \
        allow_any_name=false

      echo ""
      echo "=== Enabling ACME ==="

      # Enable ACME on intermediate CA
      vault write pki_int/config/acme enabled=true

      # Configure cluster-local ACME
      vault write pki_int/config/cluster \
        path="${VAULT_ADDR}/v1/pki_int" \
        aia_path="${VAULT_ADDR}/v1/pki_int"
    fi

    echo ""
    echo "=== Creating Kubernetes Authentication ==="

    # Enable Kubernetes auth
    vault auth enable kubernetes 2>/dev/null || echo "Kubernetes auth already enabled"

    # Configure Kubernetes auth
    vault write auth/kubernetes/config \
      kubernetes_host="https://kubernetes.default.svc:443"

    echo ""
    echo "=== Creating Policies ==="

    # Policy for cert-manager to issue certificates
    vault policy write cert-manager - <<EOF
    path "pki_int/sign/cert-manager" {
      capabilities = ["create", "update"]
    }
    path "pki_int/issue/cert-manager" {
      capabilities = ["create"]
    }
    path "pki/cert/ca" {
      capabilities = ["read"]
    }
    path "pki_int/cert/ca" {
      capabilities = ["read"]
    }
    EOF

    # Policy for reading secrets
    vault policy write secrets-reader - <<EOF
    path "secret/data/*" {
      capabilities = ["read"]
    }
    EOF

    # Create Kubernetes role for cert-manager
    vault write auth/kubernetes/role/cert-manager \
      bound_service_account_names=cert-manager \
      bound_service_account_namespaces=cert-manager \
      policies=cert-manager \
      ttl=1h

    echo ""
    echo "=== Storing Application Secrets ==="

    # Enable KV secrets engine
    vault secrets enable -path=secret -version=2 kv 2>/dev/null || echo "KV secrets engine already enabled"

    # Generate random passwords for all services
    GRAFANA_PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)
    PROMETHEUS_PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)
    ALERTMANAGER_PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)
    LOKI_PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)
    TEMPO_PASSWORD=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 16)

    # Get ArgoCD initial admin password (set by ArgoCD installation)
    ARGOCD_PASSWORD=$(kubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath='{.data.password}' | base64 -d)

    # Store all passwords in Vault (each secret includes its URL)
    vault kv put secret/homepage \
      url="https://vault-aio.local" \
      description="Vault AIO Dashboard Homepage"

    vault kv put secret/grafana \
      url="https://grafana.vault-aio.local" \
      username=admin \
      password="$GRAFANA_PASSWORD"

    vault kv put secret/prometheus \
      url="https://prometheus.vault-aio.local" \
      username=admin \
      password="$PROMETHEUS_PASSWORD"

    vault kv put secret/alertmanager \
      url="https://alertmanager.vault-aio.local" \
      username=admin \
      password="$ALERTMANAGER_PASSWORD"

    vault kv put secret/loki \
      url="https://loki.vault-aio.local" \
      username=admin \
      password="$LOKI_PASSWORD"

    vault kv put secret/tempo \
      url="https://tempo.vault-aio.local" \
      username=admin \
      password="$TEMPO_PASSWORD"

    vault kv put secret/argocd \
      url="https://argocd.vault-aio.local" \
      username=admin \
      password="$ARGOCD_PASSWORD"

    vault kv put secret/vault \
      url="https://vault.vault-aio.local" \
      token="root"

    # Store all URLs in a single secret for convenience
    vault kv put secret/urls \
      homepage="https://vault-aio.local" \
      vault="https://vault.vault-aio.local" \
      grafana="https://grafana.vault-aio.local" \
      prometheus="https://prometheus.vault-aio.local" \
      alertmanager="https://alertmanager.vault-aio.local" \
      loki="https://loki.vault-aio.local" \
      tempo="https://tempo.vault-aio.local" \
      argocd="https://argocd.vault-aio.local"

    echo ""
    echo "=== Generating Basic Auth Secrets ==="

    # Function to generate apr1 hash using openssl
    generate_htpasswd() {
      local user=$1
      local pass=$2
      local salt=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 8)
      # Use openssl to generate apr1 hash
      local hash=$(openssl passwd -apr1 -salt "$salt" "$pass")
      echo "${user}:${hash}"
    }

    # Generate htpasswd entries for each service
    PROMETHEUS_HTPASSWD=$(generate_htpasswd admin "$PROMETHEUS_PASSWORD")
    ALERTMANAGER_HTPASSWD=$(generate_htpasswd admin "$ALERTMANAGER_PASSWORD")
    LOKI_HTPASSWD=$(generate_htpasswd admin "$LOKI_PASSWORD")
    TEMPO_HTPASSWD=$(generate_htpasswd admin "$TEMPO_PASSWORD")

    echo ""
    echo "=== Exporting Secrets to Kubernetes ==="

    # Get Root CA certificate
    ROOT_CA=$(vault read -field=certificate pki/cert/ca)

    # Get Intermediate CA certificate
    INT_CA=$(vault read -field=certificate pki_int/cert/ca)

    # Create CA chain
    CA_CHAIN="${INT_CA}
    ${ROOT_CA}"

    # Store Vault credentials as Kubernetes secret
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: vault-root-token
      namespace: vault-aio
    type: Opaque
    stringData:
      token: "${VAULT_TOKEN}"
    EOSECRET

    # Store CA certificates for cert-manager
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: vault-pki-ca
      namespace: cert-manager
    type: Opaque
    stringData:
      ca.crt: |
    $(echo "$CA_CHAIN" | sed 's/^/    /')
    EOSECRET

    # Store Root CA separately
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: vault-root-ca
      namespace: vault-aio
    type: Opaque
    stringData:
      ca.crt: |
    $(echo "$ROOT_CA" | sed 's/^/    /')
    EOSECRET

    # Update Grafana secret with Vault-generated password
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: grafana-admin
      namespace: vault-aio
    type: Opaque
    stringData:
      password: "${GRAFANA_PASSWORD}"
    EOSECRET

    # Create basic auth secrets for Traefik middleware
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: prometheus-basic-auth
      namespace: vault-aio
    type: Opaque
    stringData:
      users: "${PROMETHEUS_HTPASSWD}"
    EOSECRET

    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: alertmanager-basic-auth
      namespace: vault-aio
    type: Opaque
    stringData:
      users: "${ALERTMANAGER_HTPASSWD}"
    EOSECRET

    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: loki-basic-auth
      namespace: vault-aio
    type: Opaque
    stringData:
      users: "${LOKI_HTPASSWD}"
    EOSECRET

    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: tempo-basic-auth
      namespace: vault-aio
    type: Opaque
    stringData:
      users: "${TEMPO_HTPASSWD}"
    EOSECRET

    # Store all passwords for reference
    cat <<EOSECRET | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: vault-app-passwords
      namespace: vault-aio
      annotations:
        description: "Application passwords managed by Vault"
    type: Opaque
    stringData:
      grafana-password: "${GRAFANA_PASSWORD}"
      prometheus-password: "${PROMETHEUS_PASSWORD}"
      alertmanager-password: "${ALERTMANAGER_PASSWORD}"
      loki-password: "${LOKI_PASSWORD}"
      tempo-password: "${TEMPO_PASSWORD}"
      argocd-password: "${ARGOCD_PASSWORD}"
    EOSECRET

    echo ""
    echo "=== PKI and Secrets Initialization Complete ==="
    echo ""
    echo "Root CA: pki/"
    echo "Intermediate CA: pki_int/"
    echo "ACME Endpoint: ${VAULT_ADDR}/v1/pki_int/acme/directory"
    echo ""
    echo "Secrets stored in Vault (each includes URL):"
    echo "  - secret/homepage    (url, description)"
    echo "  - secret/grafana     (url, username, password)"
    echo "  - secret/prometheus  (url, username, password)"
    echo "  - secret/alertmanager (url, username, password)"
    echo "  - secret/loki        (url, username, password)"
    echo "  - secret/tempo       (url, username, password)"
    echo "  - secret/argocd      (url, username, password)"
    echo "  - secret/vault       (url, token)"
    echo "  - secret/urls        (all URLs consolidated)"
    echo ""
    echo "Kubernetes secrets created:"
    echo "  - vault-aio/vault-app-passwords (all passwords)"
    echo "  - vault-aio/grafana-admin"
    echo "  - vault-aio/prometheus-basic-auth"
    echo "  - vault-aio/alertmanager-basic-auth"
    echo "  - vault-aio/loki-basic-auth"
    echo "  - vault-aio/tempo-basic-auth"
    echo ""
---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init
  namespace: vault-aio
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 300
  backoffLimit: 3
  template:
    spec:
      serviceAccountName: vault-init
      restartPolicy: OnFailure
      initContainers:
        # Download kubectl and openssl
        - name: download-tools
          image: alpine:3.19
          command:
            - /bin/sh
            - -c
            - |
              apk add --no-cache openssl
              cp /usr/bin/openssl /shared/openssl
              wget -O /shared/kubectl "https://dl.k8s.io/release/v1.29.0/bin/linux/amd64/kubectl"
              chmod +x /shared/kubectl /shared/openssl
          volumeMounts:
            - name: shared
              mountPath: /shared
      containers:
        - name: vault-init
          image: hashicorp/vault:1.15
          command: ["/bin/sh", "/scripts/init-vault.sh"]
          env:
            - name: VAULT_ADDR
              value: "http://vault:8200"
            - name: VAULT_TOKEN
              value: "root"
            - name: PATH
              value: "/shared:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
          volumeMounts:
            - name: scripts
              mountPath: /scripts
            - name: shared
              mountPath: /shared
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "200m"
      volumes:
        - name: scripts
          configMap:
            name: vault-init-scripts
            defaultMode: 0755
        - name: shared
          emptyDir: {}
